

#' Extract trade summary with order details from CME Market by Order data
#'
#' `mbo_match_details()` extracts trade summary with details about
#' matching (limit) orders and an incoming (market) order from CME Market by Order
#' data, including all fields extracted from `trade_summary()` and order IDs of
#' the incoming order and matching orders, matched quantity of each matching order,
#' and trade ID, etc.
#'
#' @param mbo_input A CME MBO raw data
#' @param date Trading date associated with the raw data, which can be found in
#' the file name easily in \code{YYYYMMDD} format. This argument is required to select
#' the parsing format.
#' @param price_displayformat Display format of trade price, which could be 1,
#' 0.01, or 0.001, etc. If it is unknown, the nearest Sunday's (not a
#' CME trading holiday) MBP/MBO data need to be provided to extract the display format.
#' @param sunday_input When \code{price_displayformat} is not provided, the nearest
#' Sunday's (not a national holiday)
#' MBP/MBO data need to be provided to extract the price display format.
#'
#' @returns a list of data.table that contains all trade summaries and order details
#' for all tradeable contracts in a trading day.
#' @seealso [trade_summary()], [meta_data()]
#' @export
#'
#' @import data.table stringr
#' @importFrom stats na.omit
#' @importFrom utils data
#'
#' @section Trade summary with order details:
#' CME Market by Order (MBO) is an order-based data feed that provides details of individual
#' orders. MBO records every outright order activity at each book depth. Importantly, MBO data show the queue
#' of individual orders at book depth and relevant information about order submission,
#' revision, execution and cancellation. Compared to the MBP data, the MBO extends the
#' market data feed from an aggregated level to ab individual level regarding to each incremental refresh
#' without losing information covered by the MBP. Different from the MBP data, MBO can show all matching (limit) orders and their corresponding
#' matching quantity for a trade. Hence, some extra measures related to trades, such as fill rate and execution waiting time, can be
#' computed.
#'
#' @section How to read each trade record in the data:
#' MBO data assign a unique trade ID for each trade. Generally, most trade records contain at least two order details, i.e., two rows. The
#' first order detail, i.e., first row indicates the incoming (market) order while the rest order details indicate the matching (limit) orders.
#' We refer to the CME website and more details can be found at \url{https://cmegroupclientsite.atlassian.net/wiki/spaces/EPICSANDBOX/pages/457225774/MDP+3.0+-+Trade+Summary+Order+Level+Detail}.
#' \itemize{
#' For trades with a defined aggressor (agg = 1 or agg = 2):
#' \itemize{
#' \item The matched_qty in the first order detail equals the sum of the matched_qty for the rest order details
#' \itemize{
#' \item It indicates an incoming market order matches outright orders only.}
#' \item The matched_qty in the first order detail equals the sum of the matched_qty for rest order details
#' \itemize{
#' \item It indicates an incoming market order matches both the outright orders and the implied orders.
#' The unreported quantity are matched quantity for implied orders.
#' }
#' \item When there is only one row for a trade, it probably indicates an incoming (market) order only matches implied orders.
#' }
#' For trades without a defined aggressor (agg = 0):
#' \itemize{
#' \item For individual contract, it usually happens when an implied out orders are matched in a leg market and the other leg gets matched
#' as well as a corresponding spread contract, where a trade summary message is sent for the other leg without a defined aggressor.
#' }
#' }
#'
#'
#' @section Fields of trade summary with order details:
#' \itemize{
#' \item Date: Trading date. The night trading session on Sundays is assigned
#' the trading date as the next Monday.
#' \item MsgSeq: Message sequence number for each packaet. This is unique for every
#' message, however, it is not security unique.
#' \item SendingTime: The timestamp (in UTC) indicates the time when outbound messages to clients
#' leave the segment gateway (Tag 60).
#' \item TransactTime: The timestamp (in UTC) indicates the time when incoming messages hit the segment gateway (Tag 52).
#' \item Code: Contract symbol.
#' \item Seq: Sequence number, which is security unique. A single packaet may contain information
#' for multiple tradeable contracts with the single message sequence number, while every
#' tradeable contract has its unique sequence number.
#' \item PX: Trade price.
#' \item Qty: Trade size displayed as the number of contracts.
#' \item Ord: Number of orders involved in a trade, including both matching (limit) order(s) and an incoming (market) order.
#' \item agg: Trade aggressor generated by the CME. 1 indicates buyer-initiated trades,
#' 2 indicates seller-initiated trades, while 0 indicates no trade aggressor is defined.
#' \item trade_id: Unique ID for trades.
#' \item order_id: Unique ID(s) for incoming (market) order and matching (limit) order(s).
#' \item matched_qty: The number of contracts that is matched for each individual matching (limit) orders.
#'
#'}
#'
#'
#' @examples
#' # This function requires a CME data license to run
#' # Example showing how to extract trade summary
#' # extract trade summary with order details
#' # Know the display format of trade price
#' \dontrun{
#' trade_details <- mbo_match_details(file, "2019-01-07", price_displayformat = 1)
#'
#' # Unknown price_displayformat
#' trade_details <- mbo_match_details(file, "2019-01-07", sunday_input = sunday_file)
#' }
#'
mbo_match_details <- function(mbo_input, date,
                              price_displayformat = NULL,
                              sunday_input = NULL) {
  Code <- MsgSeq <- trade_id <- end.id <- start.id <- Ord <- DisplayFactor <- PX <- NULL

  date <- as.Date(date)

  if (inherits(date, "Date") == FALSE) {
    stop("date should be in the format as YYYY-MM-DD.")

  }

  data <- fread(mbo_input,
                header = F,
                sep = "\\",
                fill = TRUE)[[1L]]


  ## loop starts##
  #test <- readLines("C:/Users/ruchuan2/Box/MBO/xcbt_md_zc_fut_20180410-r-00008")
  #Index <- gsub("\001",",",test) # delete all "\001" for each tag and replace it with "," (comma)
  #rm(test)

  Index <- str_subset(data, "\001269=2")
  Index <- str_replace_all(Index, "\001", ",")
  Trade <- str_replace_all(Index, ",269=2,", ",")

  rm(Index)
  rm(data)

  ## delete the tags that are not necessary

  Trade <- str_replace_all(Trade, "1128=([^,]*),9=([^,]*),35=([^,]*),49=([^,]*)," , "")
  Trade <- str_replace_all(Trade, ",5799=([^,]*),", ",")
  Trade <- str_replace_all(Trade, ",268=([^,]*),", ",")
  Trade <- str_replace_all(Trade, ",279=([^,]*),", ",")
  Trade <- str_replace_all(Trade, ",48=([^,]*),", ",")
  Trade <- str_replace_all(Trade, ",37705=([^,]*),", ",")
  Trade <- str_replace_all(Trade, ",269=2,", ",")


  ## searching for the following tags,
  ## tag52-time stamp
  ## tag75-date
  #  tag83-seq#
  #  tag55-contract
  #  tag269-type: 2-trade
  #  tag270-px
  #  tag271-qty
  #  tag346-# of orders in a given px level
  #  tag5797-buyer/seller initiated
  #  tag33705-order entries

  ## generate the trade data (with order flow)
  ## consider the tradings with both specific defined aggressors or non-defined aggressors (implied order or sides are not defined)
  ## tag5797=0 or tag5797=1 or tag5797=2
  ## first find the tag269=2
  ## Trade summary pattern
  ## 75 60 269=2 55 270 271 346 5797 37711-trade id 37705 37 32


  if (length(Trade) != 0) {
    ####################################### Part 1 #################################################
    ##-----------(no order details and order details together, one line, not the whole line)----------
    part1 <- str_subset(
      Trade,
      "55=([^,]*),83=([^,]*),270=([^,]*),271=([^,]*),346=([^,]*),5797=([^,]*),37711=([^,]*),"
    )
    info1 <- unlist(str_extract_all(part1, "75=([^,]*),34=([^,]*),52=([^,]*),60=([^,]*),"))

    ##-----find all 37-32 combinations
    trade_order1 <- str_match_all(part1, "37=([^,]*),32=([^,]*),")
    n_row_1 <- sapply(trade_order1, nrow) # calculate how many rows in a list element
    trade_order1 <- as.data.table(do.call(rbind, trade_order1))[, -1]
    names(trade_order1)[c(1:2)] <- c("order_id", "matched_qty")

    ## generate info 1
    info1.1 <- str_dup(info1, n_row_1)
    info1.1 <- str_match_all(info1.1, "75=([^,]*),34=([^,]*),52=([^,]*),60=([^,]*)")
    info1.1 <- as.data.table(do.call(rbind, info1.1))[, -1]
    names(info1.1)[c(1:4)] <- c("Date", "MsgSeq", "SendingTime", "TransactTime")

    info_trade_bind <- cbind(info1.1, trade_order1)

    info_trade_bind$MsgSeq <- as.numeric(info_trade_bind$MsgSeq)
    info_trade_bind$matched_qty <- as.numeric(info_trade_bind$matched_qty)

    setkey(info_trade_bind, MsgSeq)

    ##generate info 2
    info2 <- str_match_all(
      part1,
      "55=([^,]*),83=([^,]*),270=([^,]*),271=([^,]*),346=([^,]*),5797=([^,]*),37711=([^,]*),"
    )
    n_row_2 <- sapply(info2, nrow) # calculate how many rows in a list element
    info2 <- as.data.table(do.call(rbind, info2))[, -1]
    names(info2)[c(1:7)] <- c("Code", "Seq", "PX", "Qty", "Ord", "agg", "trade_id")

    info1.2 <- str_dup(info1, n_row_2)
    info1.2 <- str_match_all(info1.2, "75=([^,]*),34=([^,]*),52=([^,]*),60=([^,]*)")
    info1.2 <- as.data.table(do.call(rbind, info1.2))[, -1]
    names(info1.2)[c(1:4)] <- c("Date", "MsgSeq", "SendingTime", "TransactTime")

    info2 <- cbind(info1.2, info2)

    info2$MsgSeq <- as.numeric(info2$MsgSeq)
    info2$Seq <- as.numeric(info2$Seq)
    info2$PX <- as.numeric(info2$PX)
    info2$Qty <- as.numeric(info2$Qty)
    info2$agg <- as.numeric(info2$agg)
    info2$trade_id <- as.numeric(info2$trade_id)
    info2$Ord <- as.numeric(info2$Ord)


    setkey(info2, MsgSeq, trade_id)

    rm(n_row_1, n_row_2, info1, Trade, part1, info1.1, info1.2)

    ### merge info2 and info_trade_bind

    ##order_details ## defined by CME

    ###-------------------------------------------------------------------
    ## we assign the order details to trade summary based on message sequence number
    ## note that some trade summary may not have the complete order details
    ## we process it from each message sequence

    Message.sequence <- unique(info2$MsgSeq)


    trade.summary.all <- list()

    for (i in 1:length(Message.sequence)) {
      ## print(i)

      trade.summary <- info2[MsgSeq == Message.sequence[i]]

      trade.summary[, end.id := cumsum(Ord)]
      trade.summary[, start.id := end.id - Ord + 1]

      order_details <- info_trade_bind[MsgSeq == Message.sequence[i]]

      trade.summary.list <- list()



      trade.ID <- unique(trade.summary$trade_id)

      for (j in 1:length(trade.ID)) {
        trade.summary.single <- trade.summary[trade_id == trade.ID[j]]
        order_details.single <- na.omit(order_details[trade.summary.single$start.id:trade.summary.single$end.id])

        if (dim(order_details.single)[1] != 0) {
          trade.summary.single <- trade.summary.single[order_details.single[, c("MsgSeq", "order_id", "matched_qty")], on =
                                                         c("MsgSeq")][, -c("start.id", "end.id")]



        } else {
          trade.summary.single <- trade.summary.single[, -c("start.id", "end.id")]

        }
        trade.summary.list[[j]] <- trade.summary.single

      }

      trade.summary.list <- rbindlist(trade.summary.list, fill = TRUE)


      trade.summary.all[[i]] <- trade.summary.list

    }

    trade.summary.all <- rbindlist(trade.summary.all, fill = TRUE)

    MBO.Trade <- as.data.table(trade.summary.all)

    setkey(MBO.Trade, MsgSeq)

    rm(trade.summary.all,
       trade.summary.list,
       info2,
       info_trade_bind)

    MBO.Trade <- split(MBO.Trade, by = "Code")

    if (is.null(price_displayformat)) {
      if (is.null(sunday_input)) {
        stop(
          "Sunday's security definition at the same week must be provided to get the price display format"
        )
      }

      definition <- meta_data(sunday_input, date = date)

      setnames(definition, "Symbol", "Code")

      definition <- definition[Code %in% names(MBO.Trade)]

      MBO.Trade <- lapply(MBO.Trade, function(x) {
        x[, PX := PX * definition[Code == unique(x$Code), as.numeric(DisplayFactor)]]
        return(x)
      })



    } else{
      MBO.Trade <- lapply(MBO.Trade, function(x){
        x[, PX := as.numeric(PX) * as.numeric(price_displayformat)]
        return(x)
      })

    }

    cat(
      "CME MDP 3.0 Trade Summary with Matching Details",
      "\n",
      "contracts:",
      names(MBO.Trade)
    )
    return(MBO.Trade)

  }else{
    stop("No trade summary with order details detected")
  }


}
